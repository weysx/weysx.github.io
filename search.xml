<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>帧率是什么？29.97帧 or 30帧？</title>
      <link href="/2024/07/31/%E5%B8%A7%E7%8E%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F29.97%20or%2030%EF%BC%9F/"/>
      <url>/2024/07/31/%E5%B8%A7%E7%8E%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F29.97%20or%2030%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/%E5%A5%A5%E6%9C%AC%E6%B5%B7%E9%BB%98%E8%83%B6%E7%89%87.jpg" alt="胶片"></p><h2 id="什么是帧率？"><a href="#什么是帧率？" class="headerlink" title="什么是帧率？"></a>什么是帧率？</h2><p>所谓帧率，就是指相机每秒记录的图像帧数，即相机在1秒钟内拍摄下多少幅连续的画面。</p><p>讲到帧率，就不得不提到一个概念——<strong>“视觉暂留”</strong>，众所周知，人的视觉系统对画面有短暂的记忆能力，在同一形象不同动作连续出现的时候，只要形象的动作切换速度足够快，观者在看下一张画面时，会重叠之前一张的印象，因此产生形象在运动的效果。这是“视频”这一内容形式产生的依据。</p><h2 id="电影中的帧率"><a href="#电影中的帧率" class="headerlink" title="电影中的帧率"></a>电影中的帧率</h2><p>那么画面要以多快的速度出现，才能让人眼看的流畅呢？<br>人类的视觉系统通常能处理每秒约24到30帧的图像，所以帧率达到这个水平通常就能提供流畅的视觉体验。</p><p>早期的无声电影多数采用16～18帧，如果直接放映，看起来肯定是卡顿的，电影放映员就会采用双叶片或者三叶片的放映快门对同一个画面进行多次闪烁，这样相当于多次放映，就可以提高帧速率，达到48～54帧。</p><p><img src="/img/%E5%B8%A7.png" alt="帧"></p><p>随着有声电影的出现，电影行业的标准帧率就被统一，因为一旦播放帧率产生变化，声音就会失真，那么统一后的帧率为多少呢？24帧。</p><p>那么为什么偏偏是24帧呢？首先，当时声音是通过光学录音记录在胶片上的，为了能记录下更多的声音细节，只有不低于24帧，声音才能被不错的保留，那为什么不是23或者25呢？因为24可以被2、3、4、6、8等整除，即1&#x2F;2秒是12帧，1&#x2F;3秒是8帧……</p><h2 id="电子帧率"><a href="#电子帧率" class="headerlink" title="电子帧率"></a>电子帧率</h2><p>随着电视机的发明，产生了一种新的帧率形式——电子帧率。<br>之后便产生了钟图像呈现方式：<strong>逐行扫描</strong>和<strong>隔行扫描</strong>。</p><p><img src="/img/%E9%80%90%E8%A1%8C%E9%9A%94%E8%A1%8C.png" alt="扫描"></p><h3 id="逐行扫描（p）"><a href="#逐行扫描（p）" class="headerlink" title="逐行扫描（p）"></a>逐行扫描（p）</h3><p>逐行扫描是将每一帧的图像按照在电视中的电子束顺序一行一行扫描得到一张完整的图像。细节丰富，但流畅度低。</p><h3 id="隔行扫描（i）"><a href="#隔行扫描（i）" class="headerlink" title="隔行扫描（i）"></a>隔行扫描（i）</h3><p>隔行扫描是将荧屏按奇数行和偶数行的规则分为两个场，快速交替，让人眼看上去像一个完整的画面。牺牲画面细节来保证流畅度。</p><p>1080p 30:表示逐行扫描，每秒30帧的全帧。1080i 60表示隔行扫描，每秒60帧的半帧。</p><h2 id="30-or-29-97？50-or-60？"><a href="#30-or-29-97？50-or-60？" class="headerlink" title="30 or 29.97？50 or 60？"></a>30 or 29.97？50 or 60？</h2><p>为了消除电流和电视信号在不同频率下相互干扰，产生噪点和杂音，美国工程师就把隔行扫描的刷新率设置成和美国交流电频率60赫兹一致，隔行扫描每秒60帧半帧或者逐行扫描30帧全帧，这也就是30帧的由来。</p><h3 id="NTSC标准"><a href="#NTSC标准" class="headerlink" title="NTSC标准"></a>NTSC标准</h3><p>那么随着彩色电视的发明，又出现了一个新的问题，就是色彩信号和声音信号的频段相似，极有可能产生干扰，为了避免两者交互，工程师们又想了一个好办法，就是把画面帧率做0.1%比例的缩减，因此彩色电视的帧率从30fps下降到了29.97fps，从60fps下降到了59.94fps。</p><p><img src="/img/NTSC.png" alt="NTSC"></p><p>这就是NTSC标准，在美国、加拿大、韩国、日本等国家应用。</p><h3 id="PAL标准"><a href="#PAL标准" class="headerlink" title="PAL标准"></a>PAL标准</h3><p>PAL标准采用每秒50场进行交错扫描，也就是50i和25p。对应交流电频率50赫兹。</p><p>包括中国（中国交流电为220V 50HZ）在内的大多亚洲国家都采用PAL标准，澳大利亚、非洲、欧洲等大多也用PAL标准。<br>这也就是为什么电视节目在中国拍摄25帧或者25的倍数帧更为合理。</p><h2 id="最适合流媒体时代的帧率是什么？"><a href="#最适合流媒体时代的帧率是什么？" class="headerlink" title="最适合流媒体时代的帧率是什么？"></a>最适合流媒体时代的帧率是什么？</h2><p>要探讨这个问题，首先得从我们观看视频的设备入手，当下的手机、电脑屏幕刷新率多数为60hz、90hz、120hz。那么拍视频时到底是用25倍数帧，还是30倍数帧呢？答案显然易见，30的倍数帧。</p><p>这是否和中国广播电视行业标准50hz冲突呢？<br>是的，因为<strong>广播电视行业标准和数码产品行业标准并不一样</strong>。如果你的手机为OLED屏幕，看25帧拍摄的某些画面，则会发生卡顿。然而这个问题只会出现在中国等使用PAL标准的国家，而美国、日本等国家是不会出现这个问题的，因为他们在设计屏幕和设备时都使用的是NTSC标准，几乎没有针对50hz做硬件上的适配。</p><p>那么我们直接拍摄30帧和60帧的视频不就好了？理想很丰满，现实很骨感。为什么呢？因为大多数相机都是日本生产的，佳能、索尼……你会发现它们的菜单里只有29.97fps和59.94fps，而很多产品就算写了30fps和60fps，实际上拍出来还是29.97和59.94，非常抽象。<br>但是没关系，29.97fps和30fps，59.94fps和60fps，在我们设备的屏幕上观看几乎没有太大区别，对观看的影响微乎其微，所以在流媒体时代29.97fps和59.94fps依旧是最佳选择。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用OpenCV提取图像边缘轮廓</title>
      <link href="/2024/05/16/%E5%88%A9%E7%94%A8OpenCV%E6%8F%90%E5%8F%96%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E8%BD%AE%E5%BB%93/"/>
      <url>/2024/05/16/%E5%88%A9%E7%94%A8OpenCV%E6%8F%90%E5%8F%96%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E8%BD%AE%E5%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="利用OpenCV提取图像边缘轮廓"><a href="#利用OpenCV提取图像边缘轮廓" class="headerlink" title="利用OpenCV提取图像边缘轮廓"></a>利用OpenCV提取图像边缘轮廓</h1><p><img src="/img/houseEdgeDetection.JPG" alt="AIGC"></p><p><strong>导入库与图像</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">&#x27;路径&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-降低图像复杂度"><a href="#1-降低图像复杂度" class="headerlink" title="1.降低图像复杂度"></a>1.降低图像复杂度</h2><h4 id="转灰度图像"><a href="#转灰度图像" class="headerlink" title="转灰度图像"></a>转灰度图像</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gray_img = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><h2 id="2-去噪"><a href="#2-去噪" class="headerlink" title="2.去噪"></a>2.去噪</h2><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gauss_img = cv2.GaussianBlur(gray_img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">//（ ，）为高斯核大小ksize，只能为正奇数，宽度和高度越大越模糊</span><br></pre></td></tr></table></figure><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">median_img= cv2.medianBlur(gauss_img,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">//<span class="number">3</span>:ksize为内核大小，越大滤波效果越强，去噪更明显</span><br></pre></td></tr></table></figure><h2 id="3-二值化"><a href="#3-二值化" class="headerlink" title="3.二值化"></a>3.二值化</h2><h4 id="固定阈值处理"><a href="#固定阈值处理" class="headerlink" title="固定阈值处理"></a>固定阈值处理</h4><p>适用于光照均匀的图像，处理速度快，适合简单的二值化任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, binary_image = cv2.threshold(median_img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">//-，表示忽略第一个返回值，只返回第二个，这里第一个为阈值大小，第二个为二值化后的图像</span><br><span class="line">//<span class="number">127</span>为阈值，灰度值低于<span class="number">127</span>的像素将变为<span class="number">0</span>（黑色），高于或等于<span class="number">127</span>的像素变为<span class="number">255</span>（白色）</span><br><span class="line">//<span class="number">255</span>为最大值，超过阈值将被赋予此值</span><br></pre></td></tr></table></figure><h4 id="自适应阈值处理"><a href="#自适应阈值处理" class="headerlink" title="自适应阈值处理"></a>自适应阈值处理</h4><p>适用于光照不均匀、存在阴影或渐变光照的图像，可以更好地处理复杂的场景</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thresholded = cv2.adaptiveThreshold(median_img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">//<span class="number">255</span>：二值化结果中超过阈值的像素将设置为<span class="number">255</span></span><br><span class="line">//cv2.ADAPTIVE_THRESH_GAUSSIAN_C：使用高斯加权平均值计算局部阈值</span><br><span class="line">每个像素的阈值是根据其邻域内像素的高斯加权平均值计算的，能够更好地处理有渐变光照的图像</span><br><span class="line">//cv2.THRESH_BINARY阈值类型，这里使用二值</span><br><span class="line">//<span class="number">11</span>:block_size，必须是奇数，表示11x11的邻域用于计算每个像素的局部阈值</span><br><span class="line">//<span class="number">2</span>：该值会从计算出的平均值或加权平均值中减去，用于微调阈值</span><br></pre></td></tr></table></figure><h2 id="4-检测图像边缘和轮廓"><a href="#4-检测图像边缘和轮廓" class="headerlink" title="4.检测图像边缘和轮廓"></a>4.检测图像边缘和轮廓</h2><h4 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.Canny(image,<span class="number">30</span>,<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">//<span class="number">30</span>为低阈值，<span class="number">150</span>为高阈值，函数通过检测图像中的梯度强度，来识别边缘，低阈值和高阈值用来控制边缘的检测强度，边缘的像素值在这两个阈值之间时，只有当这些像素是从低到高阈值边缘的连接时，才被认为是边缘</span><br></pre></td></tr></table></figure><h4 id="寻找边缘"><a href="#寻找边缘" class="headerlink" title="寻找边缘"></a>寻找边缘</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contours,_ = cv2.findContours(image.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line">//cv2.RETR_EXTERNAL: 一种轮廓检索模式，只检索最外层的轮廓</span><br><span class="line">//cv2.CHAIN_APPROX_SIMPLE: 轮廓近似方法，它只保存轮廓的拐点信息，减少内存占用</span><br><span class="line">//该函数检测图像中的轮廓，返回一个列表，其中每个元素都是图像中一个轮廓的点集</span><br></pre></td></tr></table></figure><h2 id="5-绘制轮廓"><a href="#5-绘制轮廓" class="headerlink" title="5.绘制轮廓"></a>5.绘制轮廓</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(solved_img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">//contours轮廓列表，从findContours函数获取</span><br><span class="line">//-<span class="number">1</span>:指示绘制所有轮廓，如果只想绘制某个特定轮廓，可以指定其索引</span><br><span class="line">//(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)：颜色</span><br><span class="line">//<span class="number">3</span>:轮廓线条宽度</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;edges&#x27;</span>,edges)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AIGC对数字媒体的冲击</title>
      <link href="/2024/05/11/AIGC%E5%AF%B9%E6%95%B0%E5%AD%97%E5%AA%92%E4%BD%93%E7%9A%84%E5%86%B2%E5%87%BB/"/>
      <url>/2024/05/11/AIGC%E5%AF%B9%E6%95%B0%E5%AD%97%E5%AA%92%E4%BD%93%E7%9A%84%E5%86%B2%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/AIGC.jpg" alt="AIGC"></p><p>随着人工智能的飞速发展，预训练模型、生成算法等的不断迭代，催生了AIGC（生成式人工智能）的爆发。AIGC利用人工智能技术自动创作各种媒体内容，涵盖文本、图像、音频和视频等，这对于人类社会意义是里程碑式的。短期来看AIGC改变了基础的生产力工具，中期来看会改变社会的生产关系，长期来看促使整个社会生产力发生质的突破，在这样的变革中，生产要素——数据价值被极度放大。</p><p>AIGC的发展改变了许多行业的运作方式，对数字媒体行业的冲击尤其大，预计在未来将会改变数字媒体行业的结构。其在内容创作中的应用日益广泛，从自动生成新闻稿、音乐、电影剧本到视频内容，AI的应用正在重新定义创意过程。例如，AI可以根据过往的流行趋势和用户行为数据，创作出符合市场需求的内容。此外，AI还能通过学习大量的语言和图像数据库，产生具有艺术感的文本、图像和音频内容。在视频编辑和后期制作领域，AI能够自动识别视频中的关键内容，帮助编辑者进行剪辑、色彩校正和声音优化，大幅度提高制作效率和质量。</p><p>可见，AIGC几乎彻底改变了内容的创作和分发方式，传统的内容创作和发布流程正变得更加自动和智能化，这可能导致行业内角色和职能的重组，一些传统的内容编辑和制作职位可能会减少，涌现的新角色将更侧重于利用AI技术来增强创造性，未来的工作不仅需要技术能力，还要求有能力将创新融入实际应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学前置知识</title>
      <link href="/2024/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/0000.jpg" alt="Piet Cornelies Mondrian"></p><h1 id="OpenCV前置知识"><a href="#OpenCV前置知识" class="headerlink" title="OpenCV前置知识"></a>OpenCV前置知识</h1><h2 id="1-像素"><a href="#1-像素" class="headerlink" title="1.像素"></a>1.像素</h2><p><strong>像素是一张图像最小的单元，可以理解为：图像是一个像素矩阵。</strong><br>我们可以单独设置每一个像素的颜色。</p><h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2.分辨率"></a>2.分辨率</h2><p><strong>分辨率是指图像或显示器屏幕上的像素数量。（通常以AxB的形式表示）</strong><br>例如一张分辨率为1920x1080的图像，表示水平方向（长）有1920个像素，垂直方向（宽）有1080个像素。<br>分辨率越高图像越清晰，质量越好。</p><h2 id="3-通道"><a href="#3-通道" class="headerlink" title="3.通道"></a>3.通道</h2><h3 id="单通道"><a href="#单通道" class="headerlink" title="单通道"></a>单通道</h3><p><strong>单通道图像又叫灰度图像，顾名思义就是每个像素只包含一个灰度值。</strong><br>每个像素的灰度值代表了其亮度或强度，灰度值通常介于0到255之间，0代表黑色，255代表白色。中间值代表不同程度的灰度，可以表示出图像中的不同亮度级别。（所以灰度图像不一定是只有黑白，它可以包含多个灰度级别，从全黑到全白之间的各种灰度值。）</p><h3 id="三通道（RGB）"><a href="#三通道（RGB）" class="headerlink" title="三通道（RGB）"></a>三通道（RGB）</h3><p><strong>具有三个通道的图像又叫彩色图像，每个像素包含红、绿、蓝三个通道的颜色值。</strong><br>每个通道的值范围从0到255，表示该颜色通道的亮度或强度。因此，彩色图像中的每个像素实际上是一个三元组，分别表示红、绿、蓝三种颜色的亮度或强度。<br>以R通道举例：<br>R通道的取值范围通常是从0到255，这个范围代表了红色通道的亮度或强度，值越大表示红色越强，值越小表示红色越弱。<br>当R通道的值为0时，表示没有红色。<br>当R通道的值为255时，表示红色通道的最大强度，这个像素呈现出纯红色。</p><h3 id="四通道（RGBA）"><a href="#四通道（RGBA）" class="headerlink" title="四通道（RGBA）"></a>四通道（RGBA）</h3><p><strong>四通道图像（带有Alpha通道的图像）每个像素包含了红色、绿色、蓝色和透明度（Alpha）四个通道。</strong><br>四通道图像与普通的RGB图像相比，多了一个透明度通道。这个通道可以控制图像中每个像素的透明度，使得图像可以呈现出不同的透明效果。</p><h2 id="4-颜色模型"><a href="#4-颜色模型" class="headerlink" title="4.颜色模型"></a>4.颜色模型</h2><p><strong>分为加色法模型（RGB）和减色法模型（CMYK）</strong></p><h3 id="加色法模型（RGB）"><a href="#加色法模型（RGB）" class="headerlink" title="加色法模型（RGB）"></a>加色法模型（RGB）</h3><p>加色法模型一般运用于显示器和计算机。<br>因为屏幕本身是黑的，但它会发光，我们从没有光开始，在黑色表面添加不同强度的<strong>红色（R）、绿色（G）、蓝色（B）。</strong>当红、绿、蓝三种颜色的光以不同的强度叠加时，就可以产生出各种不同的颜色。</p><h3 id="减色法模型（CMYK）"><a href="#减色法模型（CMYK）" class="headerlink" title="减色法模型（CMYK）"></a>减色法模型（CMYK）</h3><p>减色法模型一般用于绘画和纸张。<br>减色法模型通常以CMYK（青、品红、黄、黑）模型为基础。<br>青色（Cyan）吸收红色光<br>品红色（Magenta）吸收绿色光<br>黄色（Yellow）吸收蓝色光<br>黑色（Key）用于调节亮度和增强色彩的深度，因此并不是一个颜色，而是一种强度。<br>一张纸是白色的，我们从白光开始减，例如我在纸上涂上了一层黄色，那么这层黄色涂料的作用就是从原始白光中减去一部分波长的光。<br>我们可以把一层层涂料看作滤波器，通过减去一部分波长来创造颜色。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D实现第一人称视角</title>
      <link href="/2023/08/19/Unity3D%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E8%A7%86%E8%A7%92/"/>
      <url>/2023/08/19/Unity3D%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E8%A7%86%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/unityfp.png" alt="unityfp"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>第一人称视角的运用十分广泛，常见于许多FPS（First-Person Shooting第一人称射击游戏）、交互式展览、空间漫游等项目。</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>那么，这类第一人称视角是如何实现的呢？</p><p>其实并不复杂，<strong>一个人物模型</strong>，<strong>一个摄像机</strong>，<strong>一个脚本</strong>，便可轻松实现。</p><h2 id="1-创建人物模型"><a href="#1-创建人物模型" class="headerlink" title="1.创建人物模型"></a>1.创建人物模型</h2><p>在 Hierarchy 栏目右击随机创建一个 3D Object</p><h2 id="2-调整摄像机位置"><a href="#2-调整摄像机位置" class="headerlink" title="2.调整摄像机位置"></a>2.调整摄像机位置</h2><p>将 Main Camera 拖动到创建好的 3D Object 模型下，成为它的子物体</p><p>调整好摄像机在模型内部的位置，充当眼睛，（建议放在中上部），来获取周围的环境</p><p>至此，一个简单的人物就做好了，有没有感到非常激动呢</p><h2 id="3-编写脚本（核心部分）"><a href="#3-编写脚本（核心部分）" class="headerlink" title="3.编写脚本（核心部分）"></a>3.编写脚本（核心部分）</h2><h3 id="姿态讲解"><a href="#姿态讲解" class="headerlink" title="姿态讲解"></a>姿态讲解</h3><p><strong>第一人称视角的旋转，事实上就是摄像机(Camera)不断发生姿态改变的过程</strong></p><p>物体在三维空间中姿态的改变，可以被描述为3种基本行为：<strong>俯仰(pitch)、偏转(yaw)、翻滚(roll)</strong><br><img src="/img/3d.png" alt="3D coordinates"></p><p><strong>俯仰（pitch）：绕X轴旋转</strong>（类似于汽车上下坡）<br><strong>偏转（yaw）：绕Y轴旋转</strong>（类似于军训原地向左转、向右转）<br><strong>翻滚（roll）：绕Z轴旋转</strong>（类似于烤串）<br>*第一人称不用Z轴</p><p>因此，想要完成第一视角的移动，我们得达到以下目的：<br><strong>鼠标向前移动时，进行向上的仰视</strong><br><strong>鼠标向后移动时，进行向下的俯视</strong><br><strong>鼠标向左移动时，进行向左(逆时针)的偏转</strong><br><strong>鼠标向右移动时，进行向右(顺时针)的偏转</strong></p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>如何用代码实现呢？<br>只需三步即可：<strong>获取摄像机</strong>、<em><strong>计算转动角度</strong>、</em><em>将计算出的值赋给摄像机</em>*</p><h4 id="获取摄像机"><a href="#获取摄像机" class="headerlink" title="获取摄像机"></a>获取摄像机</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform camera;<span class="comment">//存放相机</span></span><br></pre></td></tr></table></figure><p>在 Main Camera 的 Inspector 中要将 Main Camera 绑定到对应位置</p><h4 id="计算转动角度"><a href="#计算转动角度" class="headerlink" title="*计算转动角度"></a>*计算转动角度</h4><p><strong>欧拉角</strong><br>在Unity中，欧拉角（Euler Angles）用于描述物体的旋转状态，它由三个角度组成（X, Y, Z)，即俯仰角（pitch）、偏转角（yaw）和翻滚角（roll）<br>在Transform组件中，可以通过eulerAngles属性获取或设置物体的欧拉角</p><p>首先设定<strong>俯仰</strong>和<strong>偏转</strong>时的鼠标灵敏度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> mousePitchSensitivity;<span class="comment">//俯仰的鼠标灵敏度（绕X轴）</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> mouseYawSensitivity;<span class="comment">//偏转的鼠标灵敏度（绕Y轴）</span></span><br></pre></td></tr></table></figure><p>设定俯仰的最大角度（一般人抬头是不能看到后面的，除非你能下腰…）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> pitchLimit = <span class="number">75</span>;<span class="comment">//俯仰的最大角度</span></span><br></pre></td></tr></table></figure><p>通过<br>    * <strong>最终角度（AfterRot）&#x3D;当前角度（localEulerAngles）+变化角度（Rot）</strong><br> 进行计算</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> pitch = -Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>)*mousePitchSensitivity;<span class="comment">//当前帧的俯仰值（变化的量）</span></span><br><span class="line"><span class="built_in">float</span> yaw = Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>)*mouseYawSensitivity;<span class="comment">//当前帧的偏转值（变化的量）</span></span><br><span class="line"></span><br><span class="line">Vector3 rot = <span class="keyword">new</span> Vector3(pitch, yaw, <span class="number">0</span>);<span class="comment">//当前帧欧拉角发生的改变量</span></span><br><span class="line"></span><br><span class="line">Vector3 afterRot;<span class="comment">//改变后的欧拉角</span></span><br><span class="line">afterRot.x = Mathf.Clamp(ClampAngle(camera.localEulerAngles.x) + rot.x, -pitchLimit, pitchLimit);</span><br><span class="line">afterRot.y = camera.transform.localEulerAngles.y + rot.y;</span><br><span class="line">afterRot.z = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里用到了一个 ClampAngle 函数，用于限制角度于（-180，180）之间<br>因为在访问物体欧拉角x&#x2F;y&#x2F;z数值时，Unity返回的读出值具有周期上的随机性（例如对于俯仰角x &#x3D; 0，Transform.EulerAngle.x的读出值可能是-360，0，360中的一个）所以以此来避免</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将角度限制在（-180，180）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">ClampAngle</span>(<span class="params"><span class="built_in">float</span> angle</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( angle&lt;=<span class="number">180</span> &amp;&amp; angle&gt;=<span class="number">-180</span>) <span class="keyword">return</span> angle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (angle&gt;<span class="number">180</span>) angle-=<span class="number">360</span>;</span><br><span class="line">    <span class="keyword">else</span> angle +=<span class="number">360</span>;</span><br><span class="line">    <span class="keyword">return</span> angle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附值给摄像机"><a href="#附值给摄像机" class="headerlink" title="附值给摄像机"></a>附值给摄像机</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.localEulerAngles = afterRot;<span class="comment">//将最终的欧拉角赋给摄像机</span></span><br></pre></td></tr></table></figure><p>最后将脚本挂载在 Main Camera 上 这样第一视角便可以实现了</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics.Tracing;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LookControl</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform camera;<span class="comment">//存放相机</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mousePitchSensitivity;<span class="comment">//俯仰的鼠标灵敏度（绕X轴）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> mouseYawSensitivity;<span class="comment">//偏转的鼠标灵敏度（绕Y轴）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> pitchLimit = <span class="number">75</span>;<span class="comment">//俯仰的最大角度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将角度限制在（-180，180）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">ClampAngle</span>(<span class="params"><span class="built_in">float</span> angle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (angle&lt;=<span class="number">180</span> &amp;&amp; angle&gt;=<span class="number">-180</span>) <span class="keyword">return</span> angle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (angle&gt;<span class="number">180</span>) angle-=<span class="number">360</span>;</span><br><span class="line">        <span class="keyword">else</span> angle +=<span class="number">360</span>;</span><br><span class="line">        <span class="keyword">return</span> angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cursor.lockState=CursorLockMode.Locked;<span class="comment">//将鼠标光标锁定在窗口中心</span></span><br><span class="line">        Cursor.visible = <span class="literal">false</span>;<span class="comment">//隐藏鼠标光标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> pitch = -Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>)*mousePitchSensitivity;<span class="comment">//当前帧的俯仰值（变化的量）</span></span><br><span class="line">        <span class="built_in">float</span> yaw = Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>)*mouseYawSensitivity;<span class="comment">//当前帧的偏转值（变化的量）</span></span><br><span class="line"></span><br><span class="line">        Vector3 rot = <span class="keyword">new</span> Vector3(pitch, yaw, <span class="number">0</span>);<span class="comment">//当前帧欧拉角发生的改变量</span></span><br><span class="line"></span><br><span class="line">        Vector3 afterRot;<span class="comment">//改变后的欧拉角</span></span><br><span class="line">        afterRot.x = Mathf.Clamp(ClampAngle(camera.localEulerAngles.x) + rot.x, -pitchLimit, pitchLimit);</span><br><span class="line">        afterRot.y = camera.transform.localEulerAngles.y + rot.y;</span><br><span class="line">        afterRot.z = <span class="number">0</span>;</span><br><span class="line">        camera.localEulerAngles = afterRot;<span class="comment">//将最终的欧拉角赋给摄像机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
